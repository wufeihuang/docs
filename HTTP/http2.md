# HTTP/2

> [HTTP/2 \- 术语表 \| MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_2)
>
> [HTTP/2 简介  \|  Web Fundamentals  \|  Google Developers](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn)

HTTP/2 的关注点在于 性能，主要目标是通过启用完整的请求和响应多路复用来减少延迟，通过有效压缩 HTTP 头字段来最小化协议开销，并增加对请求优先级和服务器推送的支持。

为达成这些目标，HTTP/2 还带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。

HTTP/2 不会修改 HTTP 协议的语义，而是修改了 HTTP/2 数据在客户端和服务器之间的格式（帧）和传输方式，这两者都管理整个过程，并在新的框架层内隐藏了应用程序的复杂性。所以，所有现有的应用程序都可以不经修改地交付。

*为什么不是 HTTP/1.2？* 为了实现性能目标，HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容。

但由于所有的低级分帧由客户端和服务器执行，所以很可能在使用时注意不到区别。

HTTP/2 从谷歌开发的 SPDY 协议发展而来。2015年初，HTTP/2 标准发布。

## 二进制分帧层

HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。

这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不通过的是传输期间对它们的编码方式变了。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。

这样一来，客户端和服务器为了相互理解，都必须使用新的二进制编码机制：HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然。

## 数据流、消息和帧

- 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。
- 消息：与逻辑请求或响应消息对应的完整的一系列帧。
- 帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。

关系总结如下：

- 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。
- 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等。来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

简言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。这是 HTTP/2 协议所有其他功能和性能有优化的基础。

## 请求与响应复用

HTTP/1.x 如果要并行请求，需要使用多个 TCP 连接；每个连接每次只交付一个响应（响应排队）。这种模型还可能导致队首阻塞，从而造成底层 TCP 连接效率低下。

HTTP/2 的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务端可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。从而可以：

- 并行交错地发送多个请求，请求之间互不影响。
- 并行交错地发送多个响应，响应之间互不影响。
- 使用一个连接并行发送多个请求和响应。
- 不必再为绕过 HTTP/1.x 限制而做很多工作。
- 消除不必要的延迟和提高网络容量的利用率，从而减少页面加载时间。

## 数据流优先级

HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系。

注: 数据流依赖关系和权重表示传输优先级，而不是要求，因此不能保证特定的处理或传输顺序。

## 每个来源一个连接

基于以上，所有 HTTP/2 连接都是永久的，而且仅需要每个来源一个连接。

连接数量减少对提升 HTTPS 部署的性能来说是一项特别重要的功能: 可以减少开销较大的 TLS 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源（占用的内存和处理空间）。

## 流控制

流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。

## 服务器推送

HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多响应。

换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。

为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。

## PUSH_PROMISE 101

所有服务器推送数据流都由 PUSH_PROMISE 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。

这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求。

满足此要求的最简单策略是先于父响应（即 DATA 帧）发送所有 PUSH_PROMISE 帧，其中包含所承诺资源的 HTTP 头。

在客户端接收到 PUSH_PROMISE 帧后，它可以根据自身情况选择拒绝数据流（通过 RST_STREAM 帧）。

## 标头压缩

HTTP/1.x 中，headers 以纯文本形式传输，会给每个传输增加不少的开销，在使用 cookie 的情况开销会更多。

为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应头元数据。这种格式采用两种简单但强大的技术：

- 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输大小。
- 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。

## HPACK 的安全性和性能

早期 HTTP/2 和 SPDY 使用 zlib 压缩 headers，后来因为出现安全问题，使用 HPACK 压缩算法替代。
